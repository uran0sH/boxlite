//! Stage 6: Guest initialization.
//!
//! Sends init configuration to guest and starts container.

use crate::litebox::init::types::{GuestInput, GuestOutput, ResolvedVolume, RootfsPrepResult};
use crate::portal::interfaces::{
    GuestInitConfig, NetworkInitConfig, RootfsInitConfig, VolumeConfig as GuestVolumeConfig,
};
use crate::runtime::constants::{guest_paths, mount_tags};
use boxlite_shared::Filesystem;
use boxlite_shared::errors::BoxliteResult;
use boxlite_shared::layout::SharedGuestLayout;

/// Initialize guest and start container.
///
/// **Single Responsibility**: Guest RPC calls.
pub async fn run(input: GuestInput) -> BoxliteResult<GuestOutput> {
    let container_id_str = input.container_id.as_str();

    // Build guest init config
    let guest_init_config = build_guest_init_config(
        &input.rootfs_result,
        &input.user_volumes,
        &input.guest_shared_layout,
        container_id_str,
        input.rootfs_device_path.as_deref(),
    )?;

    // Step 1: Guest Init
    tracing::info!("Sending guest initialization request");
    let mut guest_interface = input.guest_session.guest().await?;
    guest_interface.init(guest_init_config).await?;
    tracing::info!("Guest initialized successfully");

    // Step 2: Container Init (container_id generated by host)
    tracing::info!("Sending container configuration to guest");
    let mut container_interface = input.guest_session.container().await?;
    let container_id = container_interface
        .init(container_id_str, input.container_config)
        .await?;
    tracing::info!(container_id = %container_id, "Container initialized");

    Ok(GuestOutput {
        container_id,
        guest_session: input.guest_session,
    })
}

fn build_guest_init_config(
    rootfs_result: &RootfsPrepResult,
    user_volumes: &[ResolvedVolume],
    guest_layout: &SharedGuestLayout,
    container_id: &str,
    rootfs_device_path: Option<&str>,
) -> BoxliteResult<GuestInitConfig> {
    // Get container layout for the specified container
    let container_layout = guest_layout.container(container_id);
    let rootfs_path = container_layout.rootfs_dir();
    let upper_path = container_layout.upper_dir();
    let work_path = container_layout.work_dir();

    // Rootfs configuration - all strategies use the same rootfs path
    let rootfs_path_str = rootfs_path.to_str().unwrap().to_string();
    let upper_path_str = upper_path.to_str().unwrap().to_string();
    let work_path_str = work_path.to_str().unwrap().to_string();

    // Shared directory virtiofs - needed by all strategies for host-guest communication
    let mut volumes = vec![GuestVolumeConfig::virtiofs(
        mount_tags::SHARED,
        guest_layout.base().to_str().unwrap(),
        false,
    )];

    let rootfs = match rootfs_result {
        RootfsPrepResult::Merged(_) => {
            volumes.push(GuestVolumeConfig::virtiofs(
                mount_tags::ROOTFS,
                &rootfs_path_str,
                false,
            ));
            RootfsInitConfig::Merged {
                path: rootfs_path_str,
            }
        }
        RootfsPrepResult::Layers { layer_names, .. } => {
            volumes.push(GuestVolumeConfig::virtiofs(
                mount_tags::LAYERS,
                guest_paths::LAYERS_DIR,
                false,
            ));
            let lower_dirs: Vec<String> = layer_names
                .iter()
                .map(|name| format!("{}/{}", guest_paths::LAYERS_DIR, name))
                .collect();

            RootfsInitConfig::Overlay {
                lower_dirs,
                upper_dir: upper_path_str,
                work_dir: work_path_str,
                merged_dir: rootfs_path_str,
                copy_layers: true,
            }
        }
        RootfsPrepResult::DiskImage { .. } => {
            let device =
                rootfs_device_path.expect("rootfs_device_path must be set for DiskImage mode");

            volumes.push(GuestVolumeConfig::block_device(
                device,
                &rootfs_path_str,
                Filesystem::Unspecified,
            ));

            RootfsInitConfig::DiskImage {
                device: device.to_string(),
                mount_point: rootfs_path_str,
            }
        }
    };

    for vol in user_volumes {
        volumes.push(GuestVolumeConfig::virtiofs(
            &vol.tag,
            &vol.guest_path,
            vol.read_only,
        ));
    }

    // Network configuration
    let network = Some(NetworkInitConfig {
        interface: "eth0".to_string(),
        ip: Some("192.168.127.2/24".to_string()),
        gateway: Some("192.168.127.1".to_string()),
    });

    Ok(GuestInitConfig {
        volumes,
        rootfs,
        network,
    })
}
