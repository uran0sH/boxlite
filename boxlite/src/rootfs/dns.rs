//! DNS configuration for containers
//!
//! Creates /etc/resolv.conf in the container rootfs pointing to
//! the DNS server at the gateway IP (192.168.127.1).
//!
//! DNS is configured after rootfs preparation, before the Box starts.

use boxlite_shared::errors::{BoxliteError, BoxliteResult};
use std::fs;
use std::path::Path;

/// Configure DNS for container by creating /etc/resolv.conf
///
/// Creates resolv.conf pointing to the DNS server at 192.168.127.1 (the gateway).
///
/// This is called during rootfs preparation, after image extraction
/// but before the Box starts.
///
/// # Arguments
/// * `rootfs` - Path to the container rootfs directory
///
/// # Returns
/// * `Ok(())` on success
/// * `Err` if directory creation or file writing fails
///
/// # Example
/// ```no_run
/// use std::path::Path;
/// use boxlite::rootfs::configure_container_dns;
///
/// let rootfs = Path::new("/tmp/rootfs");
/// configure_container_dns(rootfs).unwrap();
/// ```
pub fn configure_container_dns(rootfs: &Path) -> BoxliteResult<()> {
    tracing::debug!("Configuring DNS for container at {:?}", rootfs);

    // Ensure /etc directory exists in rootfs
    let etc_dir = rootfs.join("etc");
    fs::create_dir_all(&etc_dir).map_err(|e| {
        BoxliteError::Storage(format!("Failed to create /etc directory in rootfs: {}", e))
    })?;

    // Create /etc/resolv.conf with gateway as DNS server
    let resolv_conf = etc_dir.join("resolv.conf");
    let content = concat!(
        "# Generated by BoxLite\n",
        "# DNS queries forwarded to gateway\n",
        "nameserver 192.168.127.1\n",
        "search localdomain\n",
    );

    fs::write(&resolv_conf, content)
        .map_err(|e| BoxliteError::Storage(format!("Failed to write /etc/resolv.conf: {}", e)))?;

    tracing::info!("Created /etc/resolv.conf in container rootfs");
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_configure_dns_creates_file() {
        let tmp = TempDir::new().unwrap();
        let rootfs = tmp.path();

        configure_container_dns(rootfs).unwrap();

        // File should exist
        let resolv_conf = rootfs.join("etc/resolv.conf");
        assert!(resolv_conf.exists());
    }

    #[test]
    fn test_configure_dns_content() {
        let tmp = TempDir::new().unwrap();
        let rootfs = tmp.path();

        configure_container_dns(rootfs).unwrap();

        // Read and verify content
        let content = fs::read_to_string(rootfs.join("etc/resolv.conf")).unwrap();
        assert!(content.contains("nameserver 192.168.127.1"));
        assert!(content.contains("search localdomain"));
        assert!(content.contains("Generated by BoxLite"));
    }

    #[test]
    fn test_configure_dns_creates_etc_dir() {
        let tmp = TempDir::new().unwrap();
        let rootfs = tmp.path();

        // /etc should not exist initially
        assert!(!rootfs.join("etc").exists());

        configure_container_dns(rootfs).unwrap();

        // /etc should be created
        assert!(rootfs.join("etc").exists());
        assert!(rootfs.join("etc").is_dir());
    }

    #[test]
    fn test_configure_dns_idempotent() {
        let tmp = TempDir::new().unwrap();
        let rootfs = tmp.path();

        // Call twice
        configure_container_dns(rootfs).unwrap();
        configure_container_dns(rootfs).unwrap();

        // Should still work and have correct content
        let content = fs::read_to_string(rootfs.join("etc/resolv.conf")).unwrap();
        assert!(content.contains("nameserver 192.168.127.1"));
    }
}
